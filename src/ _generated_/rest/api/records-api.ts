/* tslint:disable */
/* eslint-disable */
/**
 * Skyflow Data API
 * # Data API  This API inserts, retrieves, and otherwise manages data in a vault.  The Data API is available from two base URIs. *identifier* is the identifier in your vault\'s URL.<ul><li><b>Sandbox:</b> https://_*identifier*.vault.skyflowapis-preview.com</li><li><b>Production:</b> https://_*identifier*.vault.skyflowapis.com</li></ul>  When you make an API call, you need to add a header: <table><tr><th>Header</th><th>Value</th><th>Example</th></tr><tr><td>Authorization</td><td>A Bearer Token. See <a href=\'/api-authentication/\'>API Authentication</a>.</td><td><code>Authorization: Bearer eyJhbGciOiJSUzI...1NiIsJdfPA</code></td></tr><table/>
 *
 * The version of the OpenAPI document: v1
 * Contact: support@skyflow.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
// import { FormData } from '../models';
// @ts-ignore
import type { GooglerpcStatus } from '../models';
// @ts-ignore
import type { RecordServiceBatchOperationBody } from '../models';
// @ts-ignore
import type { RecordServiceBulkDeleteRecordBody } from '../models';
// @ts-ignore
import type { RecordServiceInsertRecordBody } from '../models';
// @ts-ignore
import type { RecordServiceUpdateRecordBody } from '../models';
// @ts-ignore
import type { V1BatchOperationResponse } from '../models';
// @ts-ignore
import type { V1BulkDeleteRecordResponse } from '../models';
// @ts-ignore
import type { V1BulkGetRecordResponse } from '../models';
// @ts-ignore
import type { V1DeleteFileResponse } from '../models';
// @ts-ignore
import type { V1DeleteRecordResponse } from '../models';
// @ts-ignore
import type { V1FieldRecords } from '../models';
// @ts-ignore
import type { V1GetFileScanStatusResponse } from '../models';
// @ts-ignore
import type { V1InsertRecordResponse } from '../models';
// @ts-ignore
import type { V1UpdateRecordResponse } from '../models';
/**
 * RecordsApi - axios parameter creator
 * @export
 */
export const RecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a file from the specified record.
         * @summary Delete File
         * @param {string} vaultID ID of the vault.
         * @param {string} tableName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {string} columnName Name of the column that contains the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileServiceDeleteFile: async (vaultID: string, tableName: string, iD: string, columnName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('fileServiceDeleteFile', 'vaultID', vaultID)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('fileServiceDeleteFile', 'tableName', tableName)
            // verify required parameter 'iD' is not null or undefined
            assertParamExists('fileServiceDeleteFile', 'iD', iD)
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('fileServiceDeleteFile', 'columnName', columnName)
            const localVarPath = `/v1/vaults/{vaultID}/{tableName}/{ID}/files/{columnName}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)))
                .replace(`{${"ID"}}`, encodeURIComponent(String(iD)))
                .replace(`{${"columnName"}}`, encodeURIComponent(String(columnName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the anti-virus scan status of a file.
         * @summary Get File Scan Status
         * @param {string} vaultID ID of the vault.
         * @param {string} tableName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {string} columnName Name of the column that contains the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileServiceGetFileScanStatus: async (vaultID: string, tableName: string, iD: string, columnName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('fileServiceGetFileScanStatus', 'vaultID', vaultID)
            // verify required parameter 'tableName' is not null or undefined
            assertParamExists('fileServiceGetFileScanStatus', 'tableName', tableName)
            // verify required parameter 'iD' is not null or undefined
            assertParamExists('fileServiceGetFileScanStatus', 'iD', iD)
            // verify required parameter 'columnName' is not null or undefined
            assertParamExists('fileServiceGetFileScanStatus', 'columnName', columnName)
            const localVarPath = `/v1/vaults/{vaultID}/{tableName}/{ID}/files/{columnName}/scan-status`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"tableName"}}`, encodeURIComponent(String(tableName)))
                .replace(`{${"ID"}}`, encodeURIComponent(String(iD)))
                .replace(`{${"columnName"}}`, encodeURIComponent(String(columnName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file to the specified record.
         * @summary Upload File
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {FormData} [fileColumnName] Name of the column to store the file in. The column must have a form-data data type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileServiceUploadFile: async (vaultID: string, objectName: string, iD: string, fileColumnName?: FormData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('fileServiceUploadFile', 'vaultID', vaultID)
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('fileServiceUploadFile', 'objectName', objectName)
            // verify required parameter 'iD' is not null or undefined
            assertParamExists('fileServiceUploadFile', 'iD', iD)
            const localVarPath = `/v1/vaults/{vaultID}/{objectName}/{ID}/files`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"ID"}}`, encodeURIComponent(String(iD)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (fileColumnName !== undefined && fileColumnName.has('columnName')) { 
                localVarFormParams.append(`${fileColumnName.get('columnName')}`, fileColumnName.get('file') as File);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs multiple record operations in a single transaction.
         * @summary Batch Operation
         * @param {string} vaultID ID of the vault.
         * @param {RecordServiceBatchOperationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceBatchOperation: async (vaultID: string, body: RecordServiceBatchOperationBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('recordServiceBatchOperation', 'vaultID', vaultID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('recordServiceBatchOperation', 'body', body)
            const localVarPath = `/v1/vaults/{vaultID}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified records from a table.
         * @summary Bulk Delete Records
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {RecordServiceBulkDeleteRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceBulkDeleteRecord: async (vaultID: string, objectName: string, body: RecordServiceBulkDeleteRecordBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('recordServiceBulkDeleteRecord', 'vaultID', vaultID)
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('recordServiceBulkDeleteRecord', 'objectName', objectName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('recordServiceBulkDeleteRecord', 'body', body)
            const localVarPath = `/v1/vaults/{vaultID}/{objectName}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the specified records from a table.
         * @summary Get Record(s)
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table that contains the records.
         * @param {Array<string>} [skyflowIds] &#x60;skyflow_id&#x60; values of the records to return, with one value per &#x60;skyflow_ids&#x60; URL parameter. For example, &#x60;?skyflow_ids&#x3D;abc&amp;skyflow_ids&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns the first 25 records in the table.
         * @param {RecordServiceBulkGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.
         * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
         * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
         * @param {string} [offset] Record position at which to start receiving data.
         * @param {string} [limit] Number of record to return. Maximum 25.
         * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
         * @param {string} [columnName] Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
         * @param {Array<string>} [columnValues] Column values of the records to return, with one value per &#x60;column_values&#x60; URL parameter. For example, &#x60;?column_values&#x3D;abc&amp;column_values&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;&#x60;column_name&#x60; is mandatory when providing &#x60;column_values&#x60;. If you use column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
         * @param {RecordServiceBulkGetRecordOrderByEnum} [orderBy] Order to return records, based on &#x60;skyflow_id&#x60; values. To disable, set to &#x60;NONE&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceBulkGetRecord: async (vaultID: string, objectName: string, skyflowIds?: Array<string>, redaction?: RecordServiceBulkGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, offset?: string, limit?: string, downloadURL?: boolean, columnName?: string, columnValues?: Array<string>, orderBy?: RecordServiceBulkGetRecordOrderByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('recordServiceBulkGetRecord', 'vaultID', vaultID)
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('recordServiceBulkGetRecord', 'objectName', objectName)
            const localVarPath = `/v1/vaults/{vaultID}/{objectName}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skyflowIds) {
                localVarQueryParameter['skyflow_ids'] = skyflowIds;
            }

            if (redaction !== undefined) {
                localVarQueryParameter['redaction'] = redaction;
            }

            if (tokenization !== undefined) {
                localVarQueryParameter['tokenization'] = tokenization;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (downloadURL !== undefined) {
                localVarQueryParameter['downloadURL'] = downloadURL;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (columnValues) {
                localVarQueryParameter['column_values'] = columnValues;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn\'t delete transient field tokens. Transient field values are available until they expire based on the fields\' time-to-live (TTL) setting.
         * @summary Delete Record
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceDeleteRecord: async (vaultID: string, objectName: string, iD: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('recordServiceDeleteRecord', 'vaultID', vaultID)
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('recordServiceDeleteRecord', 'objectName', objectName)
            // verify required parameter 'iD' is not null or undefined
            assertParamExists('recordServiceDeleteRecord', 'iD', iD)
            const localVarPath = `/v1/vaults/{vaultID}/{objectName}/{ID}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"ID"}}`, encodeURIComponent(String(iD)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified record from a table.
         * @summary Get Record By ID
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {RecordServiceGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.
         * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
         * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
         * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceGetRecord: async (vaultID: string, objectName: string, iD: string, redaction?: RecordServiceGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, downloadURL?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('recordServiceGetRecord', 'vaultID', vaultID)
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('recordServiceGetRecord', 'objectName', objectName)
            // verify required parameter 'iD' is not null or undefined
            assertParamExists('recordServiceGetRecord', 'iD', iD)
            const localVarPath = `/v1/vaults/{vaultID}/{objectName}/{ID}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"ID"}}`, encodeURIComponent(String(iD)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (redaction !== undefined) {
                localVarQueryParameter['redaction'] = redaction;
            }

            if (tokenization !== undefined) {
                localVarQueryParameter['tokenization'] = tokenization;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (downloadURL !== undefined) {
                localVarQueryParameter['downloadURL'] = downloadURL;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.
         * @summary Insert Records
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {RecordServiceInsertRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceInsertRecord: async (vaultID: string, objectName: string, body: RecordServiceInsertRecordBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('recordServiceInsertRecord', 'vaultID', vaultID)
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('recordServiceInsertRecord', 'objectName', objectName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('recordServiceInsertRecord', 'body', body)
            const localVarPath = `/v1/vaults/{vaultID}/{objectName}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn\'t included, it\'s removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.
         * @summary Update Record
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {RecordServiceUpdateRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceUpdateRecord: async (vaultID: string, objectName: string, iD: string, body: RecordServiceUpdateRecordBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultID' is not null or undefined
            assertParamExists('recordServiceUpdateRecord', 'vaultID', vaultID)
            // verify required parameter 'objectName' is not null or undefined
            assertParamExists('recordServiceUpdateRecord', 'objectName', objectName)
            // verify required parameter 'iD' is not null or undefined
            assertParamExists('recordServiceUpdateRecord', 'iD', iD)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('recordServiceUpdateRecord', 'body', body)
            const localVarPath = `/v1/vaults/{vaultID}/{objectName}/{ID}`
                .replace(`{${"vaultID"}}`, encodeURIComponent(String(vaultID)))
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"ID"}}`, encodeURIComponent(String(iD)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordsApi - functional programming interface
 * @export
 */
export const RecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a file from the specified record.
         * @summary Delete File
         * @param {string} vaultID ID of the vault.
         * @param {string} tableName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {string} columnName Name of the column that contains the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileServiceDeleteFile(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1DeleteFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileServiceDeleteFile(vaultID, tableName, iD, columnName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.fileServiceDeleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the anti-virus scan status of a file.
         * @summary Get File Scan Status
         * @param {string} vaultID ID of the vault.
         * @param {string} tableName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {string} columnName Name of the column that contains the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileServiceGetFileScanStatus(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetFileScanStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileServiceGetFileScanStatus(vaultID, tableName, iD, columnName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.fileServiceGetFileScanStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads a file to the specified record.
         * @summary Upload File
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {FormData} [fileColumnName] Name of the column to store the file in. The column must have a form-data data type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileServiceUploadFile(vaultID: string, objectName: string, iD: string, fileColumnName?: FormData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileServiceUploadFile(vaultID, objectName, iD, fileColumnName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.fileServiceUploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Performs multiple record operations in a single transaction.
         * @summary Batch Operation
         * @param {string} vaultID ID of the vault.
         * @param {RecordServiceBatchOperationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordServiceBatchOperation(vaultID: string, body: RecordServiceBatchOperationBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1BatchOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordServiceBatchOperation(vaultID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.recordServiceBatchOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified records from a table.
         * @summary Bulk Delete Records
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {RecordServiceBulkDeleteRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordServiceBulkDeleteRecord(vaultID: string, objectName: string, body: RecordServiceBulkDeleteRecordBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1BulkDeleteRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordServiceBulkDeleteRecord(vaultID, objectName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.recordServiceBulkDeleteRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the specified records from a table.
         * @summary Get Record(s)
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table that contains the records.
         * @param {Array<string>} [skyflowIds] &#x60;skyflow_id&#x60; values of the records to return, with one value per &#x60;skyflow_ids&#x60; URL parameter. For example, &#x60;?skyflow_ids&#x3D;abc&amp;skyflow_ids&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns the first 25 records in the table.
         * @param {RecordServiceBulkGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.
         * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
         * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
         * @param {string} [offset] Record position at which to start receiving data.
         * @param {string} [limit] Number of record to return. Maximum 25.
         * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
         * @param {string} [columnName] Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
         * @param {Array<string>} [columnValues] Column values of the records to return, with one value per &#x60;column_values&#x60; URL parameter. For example, &#x60;?column_values&#x3D;abc&amp;column_values&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;&#x60;column_name&#x60; is mandatory when providing &#x60;column_values&#x60;. If you use column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
         * @param {RecordServiceBulkGetRecordOrderByEnum} [orderBy] Order to return records, based on &#x60;skyflow_id&#x60; values. To disable, set to &#x60;NONE&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordServiceBulkGetRecord(vaultID: string, objectName: string, skyflowIds?: Array<string>, redaction?: RecordServiceBulkGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, offset?: string, limit?: string, downloadURL?: boolean, columnName?: string, columnValues?: Array<string>, orderBy?: RecordServiceBulkGetRecordOrderByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1BulkGetRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordServiceBulkGetRecord(vaultID, objectName, skyflowIds, redaction, tokenization, fields, offset, limit, downloadURL, columnName, columnValues, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.recordServiceBulkGetRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn\'t delete transient field tokens. Transient field values are available until they expire based on the fields\' time-to-live (TTL) setting.
         * @summary Delete Record
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordServiceDeleteRecord(vaultID: string, objectName: string, iD: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1DeleteRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordServiceDeleteRecord(vaultID, objectName, iD, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.recordServiceDeleteRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the specified record from a table.
         * @summary Get Record By ID
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {RecordServiceGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.
         * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
         * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
         * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordServiceGetRecord(vaultID: string, objectName: string, iD: string, redaction?: RecordServiceGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, downloadURL?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1FieldRecords>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordServiceGetRecord(vaultID, objectName, iD, redaction, tokenization, fields, downloadURL, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.recordServiceGetRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.
         * @summary Insert Records
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {RecordServiceInsertRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordServiceInsertRecord(vaultID: string, objectName: string, body: RecordServiceInsertRecordBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InsertRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordServiceInsertRecord(vaultID, objectName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.recordServiceInsertRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn\'t included, it\'s removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.
         * @summary Update Record
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {RecordServiceUpdateRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordServiceUpdateRecord(vaultID: string, objectName: string, iD: string, body: RecordServiceUpdateRecordBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordServiceUpdateRecord(vaultID, objectName, iD, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordsApi.recordServiceUpdateRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecordsApi - factory interface
 * @export
 */
export const RecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecordsApiFp(configuration)
    return {
        /**
         * Deletes a file from the specified record.
         * @summary Delete File
         * @param {string} vaultID ID of the vault.
         * @param {string} tableName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {string} columnName Name of the column that contains the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileServiceDeleteFile(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig): AxiosPromise<V1DeleteFileResponse> {
            return localVarFp.fileServiceDeleteFile(vaultID, tableName, iD, columnName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the anti-virus scan status of a file.
         * @summary Get File Scan Status
         * @param {string} vaultID ID of the vault.
         * @param {string} tableName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {string} columnName Name of the column that contains the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileServiceGetFileScanStatus(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetFileScanStatusResponse> {
            return localVarFp.fileServiceGetFileScanStatus(vaultID, tableName, iD, columnName, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file to the specified record.
         * @summary Upload File
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {FormData} [fileColumnName] Name of the column to store the file in. The column must have a form-data data type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileServiceUploadFile(vaultID: string, objectName: string, iD: string, fileColumnName?: FormData, options?: RawAxiosRequestConfig): AxiosPromise<V1UpdateRecordResponse> {
            return localVarFp.fileServiceUploadFile(vaultID, objectName, iD, fileColumnName, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs multiple record operations in a single transaction.
         * @summary Batch Operation
         * @param {string} vaultID ID of the vault.
         * @param {RecordServiceBatchOperationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceBatchOperation(vaultID: string, body: RecordServiceBatchOperationBody, options?: RawAxiosRequestConfig): AxiosPromise<V1BatchOperationResponse> {
            return localVarFp.recordServiceBatchOperation(vaultID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified records from a table.
         * @summary Bulk Delete Records
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {RecordServiceBulkDeleteRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceBulkDeleteRecord(vaultID: string, objectName: string, body: RecordServiceBulkDeleteRecordBody, options?: RawAxiosRequestConfig): AxiosPromise<V1BulkDeleteRecordResponse> {
            return localVarFp.recordServiceBulkDeleteRecord(vaultID, objectName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the specified records from a table.
         * @summary Get Record(s)
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table that contains the records.
         * @param {Array<string>} [skyflowIds] &#x60;skyflow_id&#x60; values of the records to return, with one value per &#x60;skyflow_ids&#x60; URL parameter. For example, &#x60;?skyflow_ids&#x3D;abc&amp;skyflow_ids&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns the first 25 records in the table.
         * @param {RecordServiceBulkGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.
         * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
         * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
         * @param {string} [offset] Record position at which to start receiving data.
         * @param {string} [limit] Number of record to return. Maximum 25.
         * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
         * @param {string} [columnName] Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
         * @param {Array<string>} [columnValues] Column values of the records to return, with one value per &#x60;column_values&#x60; URL parameter. For example, &#x60;?column_values&#x3D;abc&amp;column_values&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;&#x60;column_name&#x60; is mandatory when providing &#x60;column_values&#x60;. If you use column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
         * @param {RecordServiceBulkGetRecordOrderByEnum} [orderBy] Order to return records, based on &#x60;skyflow_id&#x60; values. To disable, set to &#x60;NONE&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceBulkGetRecord(vaultID: string, objectName: string, skyflowIds?: Array<string>, redaction?: RecordServiceBulkGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, offset?: string, limit?: string, downloadURL?: boolean, columnName?: string, columnValues?: Array<string>, orderBy?: RecordServiceBulkGetRecordOrderByEnum, options?: RawAxiosRequestConfig): AxiosPromise<V1BulkGetRecordResponse> {
            return localVarFp.recordServiceBulkGetRecord(vaultID, objectName, skyflowIds, redaction, tokenization, fields, offset, limit, downloadURL, columnName, columnValues, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn\'t delete transient field tokens. Transient field values are available until they expire based on the fields\' time-to-live (TTL) setting.
         * @summary Delete Record
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceDeleteRecord(vaultID: string, objectName: string, iD: string, options?: RawAxiosRequestConfig): AxiosPromise<V1DeleteRecordResponse> {
            return localVarFp.recordServiceDeleteRecord(vaultID, objectName, iD, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified record from a table.
         * @summary Get Record By ID
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {RecordServiceGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.
         * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
         * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
         * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceGetRecord(vaultID: string, objectName: string, iD: string, redaction?: RecordServiceGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, downloadURL?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V1FieldRecords> {
            return localVarFp.recordServiceGetRecord(vaultID, objectName, iD, redaction, tokenization, fields, downloadURL, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.
         * @summary Insert Records
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {RecordServiceInsertRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceInsertRecord(vaultID: string, objectName: string, body: RecordServiceInsertRecordBody, options?: RawAxiosRequestConfig): AxiosPromise<V1InsertRecordResponse> {
            return localVarFp.recordServiceInsertRecord(vaultID, objectName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn\'t included, it\'s removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.
         * @summary Update Record
         * @param {string} vaultID ID of the vault.
         * @param {string} objectName Name of the table.
         * @param {string} iD &#x60;skyflow_id&#x60; of the record.
         * @param {RecordServiceUpdateRecordBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordServiceUpdateRecord(vaultID: string, objectName: string, iD: string, body: RecordServiceUpdateRecordBody, options?: RawAxiosRequestConfig): AxiosPromise<V1UpdateRecordResponse> {
            return localVarFp.recordServiceUpdateRecord(vaultID, objectName, iD, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecordsApi - interface
 * @export
 * @interface RecordsApi
 */
export interface RecordsApiInterface {
    /**
     * Deletes a file from the specified record.
     * @summary Delete File
     * @param {string} vaultID ID of the vault.
     * @param {string} tableName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {string} columnName Name of the column that contains the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    fileServiceDeleteFile(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig): AxiosPromise<V1DeleteFileResponse>;

    /**
     * Returns the anti-virus scan status of a file.
     * @summary Get File Scan Status
     * @param {string} vaultID ID of the vault.
     * @param {string} tableName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {string} columnName Name of the column that contains the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    fileServiceGetFileScanStatus(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetFileScanStatusResponse>;

    /**
     * Uploads a file to the specified record.
     * @summary Upload File
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {FormData} [fileColumnName] Name of the column to store the file in. The column must have a form-data data type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    fileServiceUploadFile(vaultID: string, objectName: string, iD: string, fileColumnName?: FormData, options?: RawAxiosRequestConfig): AxiosPromise<V1UpdateRecordResponse>;

    /**
     * Performs multiple record operations in a single transaction.
     * @summary Batch Operation
     * @param {string} vaultID ID of the vault.
     * @param {RecordServiceBatchOperationBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    recordServiceBatchOperation(vaultID: string, body: RecordServiceBatchOperationBody, options?: RawAxiosRequestConfig): AxiosPromise<V1BatchOperationResponse>;

    /**
     * Deletes the specified records from a table.
     * @summary Bulk Delete Records
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {RecordServiceBulkDeleteRecordBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    recordServiceBulkDeleteRecord(vaultID: string, objectName: string, body: RecordServiceBulkDeleteRecordBody, options?: RawAxiosRequestConfig): AxiosPromise<V1BulkDeleteRecordResponse>;

    /**
     * Gets the specified records from a table.
     * @summary Get Record(s)
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table that contains the records.
     * @param {Array<string>} [skyflowIds] &#x60;skyflow_id&#x60; values of the records to return, with one value per &#x60;skyflow_ids&#x60; URL parameter. For example, &#x60;?skyflow_ids&#x3D;abc&amp;skyflow_ids&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns the first 25 records in the table.
     * @param {RecordServiceBulkGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.
     * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
     * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
     * @param {string} [offset] Record position at which to start receiving data.
     * @param {string} [limit] Number of record to return. Maximum 25.
     * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
     * @param {string} [columnName] Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
     * @param {Array<string>} [columnValues] Column values of the records to return, with one value per &#x60;column_values&#x60; URL parameter. For example, &#x60;?column_values&#x3D;abc&amp;column_values&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;&#x60;column_name&#x60; is mandatory when providing &#x60;column_values&#x60;. If you use column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
     * @param {RecordServiceBulkGetRecordOrderByEnum} [orderBy] Order to return records, based on &#x60;skyflow_id&#x60; values. To disable, set to &#x60;NONE&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    recordServiceBulkGetRecord(vaultID: string, objectName: string, skyflowIds?: Array<string>, redaction?: RecordServiceBulkGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, offset?: string, limit?: string, downloadURL?: boolean, columnName?: string, columnValues?: Array<string>, orderBy?: RecordServiceBulkGetRecordOrderByEnum, options?: RawAxiosRequestConfig): AxiosPromise<V1BulkGetRecordResponse>;

    /**
     * Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn\'t delete transient field tokens. Transient field values are available until they expire based on the fields\' time-to-live (TTL) setting.
     * @summary Delete Record
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    recordServiceDeleteRecord(vaultID: string, objectName: string, iD: string, options?: RawAxiosRequestConfig): AxiosPromise<V1DeleteRecordResponse>;

    /**
     * Returns the specified record from a table.
     * @summary Get Record By ID
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {RecordServiceGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.
     * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
     * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
     * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    recordServiceGetRecord(vaultID: string, objectName: string, iD: string, redaction?: RecordServiceGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, downloadURL?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<V1FieldRecords>;

    /**
     * Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.
     * @summary Insert Records
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {RecordServiceInsertRecordBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    recordServiceInsertRecord(vaultID: string, objectName: string, body: RecordServiceInsertRecordBody, options?: RawAxiosRequestConfig): AxiosPromise<V1InsertRecordResponse>;

    /**
     * Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn\'t included, it\'s removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.
     * @summary Update Record
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {RecordServiceUpdateRecordBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApiInterface
     */
    recordServiceUpdateRecord(vaultID: string, objectName: string, iD: string, body: RecordServiceUpdateRecordBody, options?: RawAxiosRequestConfig): AxiosPromise<V1UpdateRecordResponse>;

}

/**
 * RecordsApi - object-oriented interface
 * @export
 * @class RecordsApi
 * @extends {BaseAPI}
 */
export class RecordsApi extends BaseAPI implements RecordsApiInterface {
    /**
     * Deletes a file from the specified record.
     * @summary Delete File
     * @param {string} vaultID ID of the vault.
     * @param {string} tableName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {string} columnName Name of the column that contains the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public fileServiceDeleteFile(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).fileServiceDeleteFile(vaultID, tableName, iD, columnName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the anti-virus scan status of a file.
     * @summary Get File Scan Status
     * @param {string} vaultID ID of the vault.
     * @param {string} tableName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {string} columnName Name of the column that contains the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public fileServiceGetFileScanStatus(vaultID: string, tableName: string, iD: string, columnName: string, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).fileServiceGetFileScanStatus(vaultID, tableName, iD, columnName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a file to the specified record.
     * @summary Upload File
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {FormData} [fileColumnName] Name of the column to store the file in. The column must have a form-data data type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public fileServiceUploadFile(vaultID: string, objectName: string, iD: string, fileColumnName?: FormData, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).fileServiceUploadFile(vaultID, objectName, iD, fileColumnName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs multiple record operations in a single transaction.
     * @summary Batch Operation
     * @param {string} vaultID ID of the vault.
     * @param {RecordServiceBatchOperationBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public recordServiceBatchOperation(vaultID: string, body: RecordServiceBatchOperationBody, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).recordServiceBatchOperation(vaultID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified records from a table.
     * @summary Bulk Delete Records
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {RecordServiceBulkDeleteRecordBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public recordServiceBulkDeleteRecord(vaultID: string, objectName: string, body: RecordServiceBulkDeleteRecordBody, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).recordServiceBulkDeleteRecord(vaultID, objectName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the specified records from a table.
     * @summary Get Record(s)
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table that contains the records.
     * @param {Array<string>} [skyflowIds] &#x60;skyflow_id&#x60; values of the records to return, with one value per &#x60;skyflow_ids&#x60; URL parameter. For example, &#x60;?skyflow_ids&#x3D;abc&amp;skyflow_ids&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns the first 25 records in the table.
     * @param {RecordServiceBulkGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned records. Subject to policies assigned to the API caller.
     * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
     * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
     * @param {string} [offset] Record position at which to start receiving data.
     * @param {string} [limit] Number of record to return. Maximum 25.
     * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
     * @param {string} [columnName] Name of the column. It must be configured as unique in the schema. If you provide both column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
     * @param {Array<string>} [columnValues] Column values of the records to return, with one value per &#x60;column_values&#x60; URL parameter. For example, &#x60;?column_values&#x3D;abc&amp;column_values&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;&#x60;column_name&#x60; is mandatory when providing &#x60;column_values&#x60;. If you use column name or column value, you cannot use &#x60;skyflow_ids&#x60;. Passing either of these parameters with &#x60;skyflow_ids&#x60; returns an error.
     * @param {RecordServiceBulkGetRecordOrderByEnum} [orderBy] Order to return records, based on &#x60;skyflow_id&#x60; values. To disable, set to &#x60;NONE&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public recordServiceBulkGetRecord(vaultID: string, objectName: string, skyflowIds?: Array<string>, redaction?: RecordServiceBulkGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, offset?: string, limit?: string, downloadURL?: boolean, columnName?: string, columnValues?: Array<string>, orderBy?: RecordServiceBulkGetRecordOrderByEnum, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).recordServiceBulkGetRecord(vaultID, objectName, skyflowIds, redaction, tokenization, fields, offset, limit, downloadURL, columnName, columnValues, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn\'t delete transient field tokens. Transient field values are available until they expire based on the fields\' time-to-live (TTL) setting.
     * @summary Delete Record
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public recordServiceDeleteRecord(vaultID: string, objectName: string, iD: string, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).recordServiceDeleteRecord(vaultID, objectName, iD, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified record from a table.
     * @summary Get Record By ID
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {RecordServiceGetRecordRedactionEnum} [redaction] Redaction level to enforce for the returned record. Subject to policies assigned to the API caller.
     * @param {boolean} [tokenization] If &#x60;true&#x60;, this operation returns tokens for fields with tokenization enabled. Only applicable if &#x60;skyflow_id&#x60; values are specified.
     * @param {Array<string>} [fields] Fields to return for the record, with one value per &#x60;fields&#x60; URL parameter. For example, &#x60;?fields&#x3D;abc&amp;fields&#x3D;123&#x60;.&lt;br /&gt;&lt;br /&gt;If not specified, returns all fields.
     * @param {boolean} [downloadURL] If &#x60;true&#x60;, returns download URLs for fields with a file data type. URLs are valid for 15 minutes. If virus scanning is enabled, only returns if the file is clean.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public recordServiceGetRecord(vaultID: string, objectName: string, iD: string, redaction?: RecordServiceGetRecordRedactionEnum, tokenization?: boolean, fields?: Array<string>, downloadURL?: boolean, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).recordServiceGetRecord(vaultID, objectName, iD, redaction, tokenization, fields, downloadURL, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.
     * @summary Insert Records
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {RecordServiceInsertRecordBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public recordServiceInsertRecord(vaultID: string, objectName: string, body: RecordServiceInsertRecordBody, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).recordServiceInsertRecord(vaultID, objectName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn\'t included, it\'s removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.
     * @summary Update Record
     * @param {string} vaultID ID of the vault.
     * @param {string} objectName Name of the table.
     * @param {string} iD &#x60;skyflow_id&#x60; of the record.
     * @param {RecordServiceUpdateRecordBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public recordServiceUpdateRecord(vaultID: string, objectName: string, iD: string, body: RecordServiceUpdateRecordBody, options?: RawAxiosRequestConfig) {
        return RecordsApiFp(this.configuration).recordServiceUpdateRecord(vaultID, objectName, iD, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RecordServiceBulkGetRecordRedactionEnum = {
    Default: 'DEFAULT',
    Redacted: 'REDACTED',
    Masked: 'MASKED',
    PlainText: 'PLAIN_TEXT'
} as const;
export type RecordServiceBulkGetRecordRedactionEnum = typeof RecordServiceBulkGetRecordRedactionEnum[keyof typeof RecordServiceBulkGetRecordRedactionEnum];
/**
 * @export
 */
export const RecordServiceBulkGetRecordOrderByEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING',
    None: 'NONE'
} as const;
export type RecordServiceBulkGetRecordOrderByEnum = typeof RecordServiceBulkGetRecordOrderByEnum[keyof typeof RecordServiceBulkGetRecordOrderByEnum];
/**
 * @export
 */
export const RecordServiceGetRecordRedactionEnum = {
    Default: 'DEFAULT',
    Redacted: 'REDACTED',
    Masked: 'MASKED',
    PlainText: 'PLAIN_TEXT'
} as const;
export type RecordServiceGetRecordRedactionEnum = typeof RecordServiceGetRecordRedactionEnum[keyof typeof RecordServiceGetRecordRedactionEnum];
