/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Skyflow from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";
import * as fs from "fs";
import { Blob } from "buffer";

export declare namespace Records {
    export interface Options {
        environment?: core.Supplier<environments.SkyflowEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token: core.Supplier<core.BearerToken>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class Records {
    constructor(protected readonly _options: Records.Options) {}

    /**
     * Performs multiple record operations in a single transaction.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {Skyflow.RecordServiceBatchOperationBody} request
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.recordServiceBatchOperation("vaultID", {
     *         records: [{
     *                 fields: {
     *                     "drivers_license_number": "89867453",
     *                     "name": "Connor",
     *                     "phone_number": "8794523160",
     *                     "ssn": "143-89-2306"
     *                 },
     *                 tableName: "persons",
     *                 method: "POST",
     *                 batchID: "persons-12345",
     *                 redaction: "PLAIN_TEXT",
     *                 tokenization: false,
     *                 downloadURL: false,
     *                 upsert: "drivers_license_number"
     *             }, {
     *                 tableName: "persons",
     *                 method: "GET",
     *                 batchID: "persons-12345",
     *                 redaction: "PLAIN_TEXT",
     *                 tokenization: false,
     *                 ID: "f1dbc55c-7c9b-495d-9a36-72bb2b619202",
     *                 downloadURL: true
     *             }]
     *     })
     */
    public recordServiceBatchOperation(
        vaultId: string,
        request: Skyflow.RecordServiceBatchOperationBody = {},
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1BatchOperationResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__recordServiceBatchOperation(vaultId, request, requestOptions),
        );
    }

    private async __recordServiceBatchOperation(
        vaultId: string,
        request: Skyflow.RecordServiceBatchOperationBody = {},
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1BatchOperationResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1BatchOperationResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling POST /v1/vaults/{vaultID}.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Gets the specified records from a table.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} objectName - Name of the table that contains the records.
     * @param {Skyflow.RecordServiceBulkGetRecordRequest} request
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.recordServiceBulkGetRecord("vaultID", "objectName")
     */
    public recordServiceBulkGetRecord(
        vaultId: string,
        objectName: string,
        request: Skyflow.RecordServiceBulkGetRecordRequest = {},
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1BulkGetRecordResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__recordServiceBulkGetRecord(vaultId, objectName, request, requestOptions),
        );
    }

    private async __recordServiceBulkGetRecord(
        vaultId: string,
        objectName: string,
        request: Skyflow.RecordServiceBulkGetRecordRequest = {},
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1BulkGetRecordResponse>> {
        const {
            skyflow_ids: skyflowIds,
            redaction,
            tokenization,
            fields,
            offset,
            limit,
            downloadURL: downloadUrl,
            column_name: columnName,
            column_values: columnValues,
            order_by: orderBy,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (skyflowIds != null) {
            if (Array.isArray(skyflowIds)) {
                _queryParams["skyflow_ids"] = skyflowIds.map((item) => item);
            } else {
                _queryParams["skyflow_ids"] = skyflowIds;
            }
        }

        if (redaction != null) {
            _queryParams["redaction"] = redaction;
        }

        if (tokenization != null) {
            _queryParams["tokenization"] = tokenization.toString();
        }

        if (fields != null) {
            if (Array.isArray(fields)) {
                _queryParams["fields"] = fields.map((item) => item);
            } else {
                _queryParams["fields"] = fields;
            }
        }

        if (offset != null) {
            _queryParams["offset"] = offset;
        }

        if (limit != null) {
            _queryParams["limit"] = limit;
        }

        if (downloadUrl != null) {
            _queryParams["downloadURL"] = downloadUrl.toString();
        }

        if (columnName != null) {
            _queryParams["column_name"] = columnName;
        }

        if (columnValues != null) {
            if (Array.isArray(columnValues)) {
                _queryParams["column_values"] = columnValues.map((item) => item);
            } else {
                _queryParams["column_values"] = columnValues;
            }
        }

        if (orderBy != null) {
            _queryParams["order_by"] = orderBy;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(objectName)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1BulkGetRecordResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling GET /v1/vaults/{vaultID}/{objectName}.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Inserts a record in the specified table.<br /><br />The time-to-live (TTL) for a transient field begins when the field value is set during record insertion.<br /><br />Columns that have a string data type and a uniqueness constraint accept strings up to 2500 characters. If an inserted string exceeds 2500 characters, the call returns a token insertion error.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} objectName - Name of the table.
     * @param {Skyflow.RecordServiceInsertRecordBody} request
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.recordServiceInsertRecord("vaultID", "objectName", {
     *         records: [{
     *                 fields: {
     *                     "drivers_license_number": "13456789",
     *                     "name": "John",
     *                     "phone_number": "1236784563",
     *                     "ssn": "123-45-6789"
     *                 }
     *             }, {
     *                 fields: {
     *                     "drivers_license_number": "98765432",
     *                     "name": "James",
     *                     "phone_number": "9876543215",
     *                     "ssn": "345-45-9876"
     *                 }
     *             }],
     *         tokenization: true,
     *         upsert: "drivers_license_number",
     *         homogeneous: false
     *     })
     */
    public recordServiceInsertRecord(
        vaultId: string,
        objectName: string,
        request: Skyflow.RecordServiceInsertRecordBody = {},
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1InsertRecordResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__recordServiceInsertRecord(vaultId, objectName, request, requestOptions),
        );
    }

    private async __recordServiceInsertRecord(
        vaultId: string,
        objectName: string,
        request: Skyflow.RecordServiceInsertRecordBody = {},
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1InsertRecordResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(objectName)}`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1InsertRecordResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling POST /v1/vaults/{vaultID}/{objectName}.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes the specified records from a table.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} objectName - Name of the table.
     * @param {Skyflow.RecordServiceBulkDeleteRecordBody} request
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.recordServiceBulkDeleteRecord("vaultID", "objectName", {
     *         skyflow_ids: ["51782ea4-91a5-4430-a06d-f4b76efd3d2f", "110ce08f-6059-4874-b1ae-7c6651d286ff"]
     *     })
     */
    public recordServiceBulkDeleteRecord(
        vaultId: string,
        objectName: string,
        request: Skyflow.RecordServiceBulkDeleteRecordBody = {},
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1BulkDeleteRecordResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__recordServiceBulkDeleteRecord(vaultId, objectName, request, requestOptions),
        );
    }

    private async __recordServiceBulkDeleteRecord(
        vaultId: string,
        objectName: string,
        request: Skyflow.RecordServiceBulkDeleteRecordBody = {},
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1BulkDeleteRecordResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(objectName)}`,
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1BulkDeleteRecordResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling DELETE /v1/vaults/{vaultID}/{objectName}.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the specified record from a table.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} objectName - Name of the table.
     * @param {string} id - `skyflow_id` of the record.
     * @param {Skyflow.RecordServiceGetRecordRequest} request
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.recordServiceGetRecord("vaultID", "objectName", "ID")
     */
    public recordServiceGetRecord(
        vaultId: string,
        objectName: string,
        id: string,
        request: Skyflow.RecordServiceGetRecordRequest = {},
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1FieldRecords> {
        return core.HttpResponsePromise.fromPromise(
            this.__recordServiceGetRecord(vaultId, objectName, id, request, requestOptions),
        );
    }

    private async __recordServiceGetRecord(
        vaultId: string,
        objectName: string,
        id: string,
        request: Skyflow.RecordServiceGetRecordRequest = {},
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1FieldRecords>> {
        const { redaction, tokenization, fields, downloadURL: downloadUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (redaction != null) {
            _queryParams["redaction"] = redaction;
        }

        if (tokenization != null) {
            _queryParams["tokenization"] = tokenization.toString();
        }

        if (fields != null) {
            if (Array.isArray(fields)) {
                _queryParams["fields"] = fields.map((item) => item);
            } else {
                _queryParams["fields"] = fields;
            }
        }

        if (downloadUrl != null) {
            _queryParams["downloadURL"] = downloadUrl.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(objectName)}/${encodeURIComponent(id)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1FieldRecords, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling GET /v1/vaults/{vaultID}/{objectName}/{ID}.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates the specified record in a table.<br /><br />When you update a field, include the entire contents you want the field to store. For JSON fields, include all nested fields and values. If a nested field isn't included, it's removed.<br /><br />The time-to-live (TTL) for a transient field resets when the field value is updated.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} objectName - Name of the table.
     * @param {string} id - `skyflow_id` of the record.
     * @param {Skyflow.RecordServiceUpdateRecordBody} request
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.recordServiceUpdateRecord("vaultID", "objectName", "ID", {
     *         record: {
     *             fields: {
     *                 "drivers_license_number": "89867453",
     *                 "name": "Steve Smith",
     *                 "phone_number": "8794523160",
     *                 "ssn": "143-89-2306"
     *             }
     *         },
     *         tokenization: true
     *     })
     */
    public recordServiceUpdateRecord(
        vaultId: string,
        objectName: string,
        id: string,
        request: Skyflow.RecordServiceUpdateRecordBody = {},
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1UpdateRecordResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__recordServiceUpdateRecord(vaultId, objectName, id, request, requestOptions),
        );
    }

    private async __recordServiceUpdateRecord(
        vaultId: string,
        objectName: string,
        id: string,
        request: Skyflow.RecordServiceUpdateRecordBody = {},
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1UpdateRecordResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(objectName)}/${encodeURIComponent(id)}`,
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1UpdateRecordResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling PUT /v1/vaults/{vaultID}/{objectName}/{ID}.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes the specified record from a table.<br /><br /><b>Note:</b> This method doesn't delete transient field tokens. Transient field values are available until they expire based on the fields' time-to-live (TTL) setting.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} objectName - Name of the table.
     * @param {string} id - `skyflow_id` of the record to delete.
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.recordServiceDeleteRecord("vaultID", "objectName", "ID")
     */
    public recordServiceDeleteRecord(
        vaultId: string,
        objectName: string,
        id: string,
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1DeleteRecordResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__recordServiceDeleteRecord(vaultId, objectName, id, requestOptions),
        );
    }

    private async __recordServiceDeleteRecord(
        vaultId: string,
        objectName: string,
        id: string,
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1DeleteRecordResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(objectName)}/${encodeURIComponent(id)}`,
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1DeleteRecordResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling DELETE /v1/vaults/{vaultID}/{objectName}/{ID}.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Uploads a file to the specified record.
     *
     * @param {File | fs.ReadStream | Blob | undefined} file
     * @param {string} vaultId
     * @param {string} objectName
     * @param {string} id
     * @param {Skyflow.FileServiceUploadFileRequest} request
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.fileServiceUploadFile(fs.createReadStream("/path/to/your/file"), "vaultID", "objectName", "ID", {})
     */
    public fileServiceUploadFile(
        file: File | fs.ReadStream | Blob | undefined,
        vaultId: string,
        objectName: string,
        id: string,
        request: Skyflow.FileServiceUploadFileRequest,
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1UpdateRecordResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__fileServiceUploadFile(file, vaultId, objectName, id, request, requestOptions),
        );
    }

    private async __fileServiceUploadFile(
        file: File | fs.ReadStream | Blob | undefined,
        vaultId: string,
        objectName: string,
        id: string,
        request: Skyflow.FileServiceUploadFileRequest,
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1UpdateRecordResponse>> {
        const _request = await core.newFormData();
        if (file != null) {
            await _request.appendFile("file", file);
        }

        if (request.columnName != null) {
            _request.append("columnName", request.columnName);
        }

        const _maybeEncodedRequest = await _request.getRequest();
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(objectName)}/${encodeURIComponent(id)}/files`,
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ..._maybeEncodedRequest.headers,
                ...requestOptions?.headers,
            },
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1UpdateRecordResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling POST /v1/vaults/{vaultID}/{objectName}/{ID}/files.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a file from the specified record.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} tableName - Name of the table.
     * @param {string} id - `skyflow_id` of the record.
     * @param {string} columnName - Name of the column that contains the file.
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.fileServiceDeleteFile("vaultID", "tableName", "ID", "columnName")
     */
    public fileServiceDeleteFile(
        vaultId: string,
        tableName: string,
        id: string,
        columnName: string,
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1DeleteFileResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__fileServiceDeleteFile(vaultId, tableName, id, columnName, requestOptions),
        );
    }

    private async __fileServiceDeleteFile(
        vaultId: string,
        tableName: string,
        id: string,
        columnName: string,
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1DeleteFileResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(tableName)}/${encodeURIComponent(id)}/files/${encodeURIComponent(columnName)}`,
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1DeleteFileResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling DELETE /v1/vaults/{vaultID}/{tableName}/{ID}/files/{columnName}.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the anti-virus scan status of a file.
     *
     * @param {string} vaultId - ID of the vault.
     * @param {string} tableName - Name of the table.
     * @param {string} id - `skyflow_id` of the record.
     * @param {string} columnName - Name of the column that contains the file.
     * @param {Records.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.records.fileServiceGetFileScanStatus("vaultID", "tableName", "ID", "columnName")
     */
    public fileServiceGetFileScanStatus(
        vaultId: string,
        tableName: string,
        id: string,
        columnName: string,
        requestOptions?: Records.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1GetFileScanStatusResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__fileServiceGetFileScanStatus(vaultId, tableName, id, columnName, requestOptions),
        );
    }

    private async __fileServiceGetFileScanStatus(
        vaultId: string,
        tableName: string,
        id: string,
        columnName: string,
        requestOptions?: Records.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1GetFileScanStatusResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/vaults/${encodeURIComponent(vaultId)}/${encodeURIComponent(tableName)}/${encodeURIComponent(id)}/files/${encodeURIComponent(columnName)}/scan-status`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1GetFileScanStatusResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError(
                    "Timeout exceeded when calling GET /v1/vaults/{vaultID}/{tableName}/{ID}/files/{columnName}/scan-status.",
                );
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
