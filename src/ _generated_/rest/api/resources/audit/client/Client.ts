/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Skyflow from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace Audit {
    export interface Options {
        environment?: core.Supplier<environments.SkyflowEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token: core.Supplier<core.BearerToken>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class Audit {
    constructor(protected readonly _options: Audit.Options) {}

    /**
     * Lists audit events that match query parameters.
     *
     * @param {Skyflow.AuditServiceListAuditEventsRequest} request
     * @param {Audit.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.audit.auditServiceListAuditEvents({
     *         "filterOps.accountID": "filterOps.accountID"
     *     })
     */
    public auditServiceListAuditEvents(
        request: Skyflow.AuditServiceListAuditEventsRequest,
        requestOptions?: Audit.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1AuditResponse> {
        return core.HttpResponsePromise.fromPromise(this.__auditServiceListAuditEvents(request, requestOptions));
    }

    private async __auditServiceListAuditEvents(
        request: Skyflow.AuditServiceListAuditEventsRequest,
        requestOptions?: Audit.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1AuditResponse>> {
        const {
            "filterOps.context.changeID": filterOpsContextChangeId,
            "filterOps.context.requestID": filterOpsContextRequestId,
            "filterOps.context.traceID": filterOpsContextTraceId,
            "filterOps.context.sessionID": filterOpsContextSessionId,
            "filterOps.context.actor": filterOpsContextActor,
            "filterOps.context.actorType": filterOpsContextActorType,
            "filterOps.context.accessType": filterOpsContextAccessType,
            "filterOps.context.ipAddress": filterOpsContextIpAddress,
            "filterOps.context.origin": filterOpsContextOrigin,
            "filterOps.context.authMode": filterOpsContextAuthMode,
            "filterOps.context.jwtID": filterOpsContextJwtId,
            "filterOps.context.bearerTokenContextID": filterOpsContextBearerTokenContextId,
            "filterOps.parentAccountID": filterOpsParentAccountId,
            "filterOps.accountID": filterOpsAccountId,
            "filterOps.workspaceID": filterOpsWorkspaceId,
            "filterOps.vaultID": filterOpsVaultId,
            "filterOps.resourceIDs": filterOpsResourceIDs,
            "filterOps.actionType": filterOpsActionType,
            "filterOps.resourceType": filterOpsResourceType,
            "filterOps.tags": filterOpsTags,
            "filterOps.responseCode": filterOpsResponseCode,
            "filterOps.startTime": filterOpsStartTime,
            "filterOps.endTime": filterOpsEndTime,
            "filterOps.apiName": filterOpsApiName,
            "filterOps.responseMessage": filterOpsResponseMessage,
            "filterOps.httpMethod": filterOpsHttpMethod,
            "filterOps.httpURI": filterOpsHttpUri,
            "sortOps.sortBy": sortOpsSortBy,
            "sortOps.orderBy": sortOpsOrderBy,
            "afterOps.timestamp": afterOpsTimestamp,
            "afterOps.changeID": afterOpsChangeId,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (filterOpsContextChangeId != null) {
            _queryParams["filterOps.context.changeID"] = filterOpsContextChangeId;
        }

        if (filterOpsContextRequestId != null) {
            _queryParams["filterOps.context.requestID"] = filterOpsContextRequestId;
        }

        if (filterOpsContextTraceId != null) {
            _queryParams["filterOps.context.traceID"] = filterOpsContextTraceId;
        }

        if (filterOpsContextSessionId != null) {
            _queryParams["filterOps.context.sessionID"] = filterOpsContextSessionId;
        }

        if (filterOpsContextActor != null) {
            _queryParams["filterOps.context.actor"] = filterOpsContextActor;
        }

        if (filterOpsContextActorType != null) {
            _queryParams["filterOps.context.actorType"] = filterOpsContextActorType;
        }

        if (filterOpsContextAccessType != null) {
            _queryParams["filterOps.context.accessType"] = filterOpsContextAccessType;
        }

        if (filterOpsContextIpAddress != null) {
            _queryParams["filterOps.context.ipAddress"] = filterOpsContextIpAddress;
        }

        if (filterOpsContextOrigin != null) {
            _queryParams["filterOps.context.origin"] = filterOpsContextOrigin;
        }

        if (filterOpsContextAuthMode != null) {
            _queryParams["filterOps.context.authMode"] = filterOpsContextAuthMode;
        }

        if (filterOpsContextJwtId != null) {
            _queryParams["filterOps.context.jwtID"] = filterOpsContextJwtId;
        }

        if (filterOpsContextBearerTokenContextId != null) {
            _queryParams["filterOps.context.bearerTokenContextID"] = filterOpsContextBearerTokenContextId;
        }

        if (filterOpsParentAccountId != null) {
            _queryParams["filterOps.parentAccountID"] = filterOpsParentAccountId;
        }

        _queryParams["filterOps.accountID"] = filterOpsAccountId;
        if (filterOpsWorkspaceId != null) {
            _queryParams["filterOps.workspaceID"] = filterOpsWorkspaceId;
        }

        if (filterOpsVaultId != null) {
            _queryParams["filterOps.vaultID"] = filterOpsVaultId;
        }

        if (filterOpsResourceIDs != null) {
            _queryParams["filterOps.resourceIDs"] = filterOpsResourceIDs;
        }

        if (filterOpsActionType != null) {
            _queryParams["filterOps.actionType"] = filterOpsActionType;
        }

        if (filterOpsResourceType != null) {
            _queryParams["filterOps.resourceType"] = filterOpsResourceType;
        }

        if (filterOpsTags != null) {
            _queryParams["filterOps.tags"] = filterOpsTags;
        }

        if (filterOpsResponseCode != null) {
            _queryParams["filterOps.responseCode"] = filterOpsResponseCode.toString();
        }

        if (filterOpsStartTime != null) {
            _queryParams["filterOps.startTime"] = filterOpsStartTime;
        }

        if (filterOpsEndTime != null) {
            _queryParams["filterOps.endTime"] = filterOpsEndTime;
        }

        if (filterOpsApiName != null) {
            _queryParams["filterOps.apiName"] = filterOpsApiName;
        }

        if (filterOpsResponseMessage != null) {
            _queryParams["filterOps.responseMessage"] = filterOpsResponseMessage;
        }

        if (filterOpsHttpMethod != null) {
            _queryParams["filterOps.httpMethod"] = filterOpsHttpMethod;
        }

        if (filterOpsHttpUri != null) {
            _queryParams["filterOps.httpURI"] = filterOpsHttpUri;
        }

        if (sortOpsSortBy != null) {
            _queryParams["sortOps.sortBy"] = sortOpsSortBy;
        }

        if (sortOpsOrderBy != null) {
            _queryParams["sortOps.orderBy"] = sortOpsOrderBy;
        }

        if (afterOpsTimestamp != null) {
            _queryParams["afterOps.timestamp"] = afterOpsTimestamp;
        }

        if (afterOpsChangeId != null) {
            _queryParams["afterOps.changeID"] = afterOpsChangeId;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                "v1/audit/events",
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1AuditResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(
                        _response.error.body as Record<string, unknown>,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling GET /v1/audit/events.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
