/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Skyflow from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace Policies {
    export interface Options {
        environment?: core.Supplier<environments.SkyflowEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the X-Skyflow-Account-ID header */
        skyflowAccountId?: core.Supplier<string | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the X-Skyflow-Account-ID header */
        skyflowAccountId?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class Policies {
    constructor(protected readonly _options: Policies.Options = {}) {}

    /**
     * Lists policies associated with a resource.
     *
     * @param {Skyflow.PolicyAuthoringServiceListPoliciesRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceListPolicies({
     *         "resource.ID": "resource.ID",
     *         "resource.type": "NONE",
     *         "resource.name": "resource.name",
     *         "resource.namespace": "resource.namespace",
     *         "resource.description": "resource.description",
     *         "resource.status": "NONE",
     *         "resource.displayName": "resource.displayName",
     *         "filterOps.name": "filterOps.name",
     *         "sortOps.sortBy": "sortOps.sortBy",
     *         "sortOps.orderBy": "ASCENDING",
     *         offset: "offset",
     *         limit: "limit"
     *     })
     */
    public policyAuthoringServiceListPolicies(
        request: Skyflow.PolicyAuthoringServiceListPoliciesRequest,
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1ListPoliciesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__policyAuthoringServiceListPolicies(request, requestOptions));
    }

    private async __policyAuthoringServiceListPolicies(
        request: Skyflow.PolicyAuthoringServiceListPoliciesRequest,
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1ListPoliciesResponse>> {
        const {
            "resource.ID": resourceId,
            "resource.type": resourceType,
            "resource.name": resourceName,
            "resource.namespace": resourceNamespace,
            "resource.description": resourceDescription,
            "resource.status": resourceStatus,
            "resource.displayName": resourceDisplayName,
            "filterOps.name": filterOpsName,
            "sortOps.sortBy": sortOpsSortBy,
            "sortOps.orderBy": sortOpsOrderBy,
            offset,
            limit,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["resource.ID"] = resourceId;
        _queryParams["resource.type"] = resourceType;
        if (resourceName != null) {
            _queryParams["resource.name"] = resourceName;
        }

        if (resourceNamespace != null) {
            _queryParams["resource.namespace"] = resourceNamespace;
        }

        if (resourceDescription != null) {
            _queryParams["resource.description"] = resourceDescription;
        }

        if (resourceStatus != null) {
            _queryParams["resource.status"] = resourceStatus;
        }

        if (resourceDisplayName != null) {
            _queryParams["resource.displayName"] = resourceDisplayName;
        }

        if (filterOpsName != null) {
            _queryParams["filterOps.name"] = filterOpsName;
        }

        if (sortOpsSortBy != null) {
            _queryParams["sortOps.sortBy"] = sortOpsSortBy;
        }

        if (sortOpsOrderBy != null) {
            _queryParams["sortOps.orderBy"] = sortOpsOrderBy;
        }

        if (offset != null) {
            _queryParams["offset"] = offset;
        }

        if (limit != null) {
            _queryParams["limit"] = limit;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                "v1/policies",
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1ListPoliciesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling GET /v1/policies.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a policy for the specified resource.
     *
     * @param {Skyflow.V1CreatePolicyRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceCreatePolicy({
     *         name: "cupidatat velit",
     *         displayName: "proident Duis ad sint",
     *         description: "esse laborum minim occ",
     *         resource: {
     *             ID: "enim ut non adipisicing",
     *             type: "NONE",
     *             name: "dolor magna sint dolor",
     *             namespace: "velit commodo",
     *             description: "ullamco veniam laboris culpa",
     *             status: "NONE",
     *             displayName: "nostrud aute Duis"
     *         },
     *         ruleParams: [{
     *                 name: "enim ",
     *                 ID: "in magna irure commodo quis",
     *                 ruleExpression: "exercitation dolor",
     *                 columnRuleParams: {
     *                     vaultID: "ea incididunt",
     *                     columns: ["eu dolore id voluptate officia", "ex ullamco", "dolore pariatur"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "exercitation do ut",
     *                     redaction: "exercitation anim",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 tableRuleParams: {
     *                     vaultID: "eiusmod ",
     *                     tableName: "elit",
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "est ut esse",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 columnGroupRuleParams: {
     *                     vaultID: "sint cupidatat sit Duis",
     *                     columnGroups: ["deserunt", "aliquip", "aliqua voluptate sit culpa Ut"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "minim anim ullamco commodo",
     *                     redaction: "nostrud qui labore",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 }
     *             }, {
     *                 name: "occaecat",
     *                 ID: "dolor",
     *                 ruleExpression: "dolor nulla dolor quis proident",
     *                 columnRuleParams: {
     *                     vaultID: "anim nisi",
     *                     columns: ["veniam sit adipisi", "minim", "enim"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "mollit nulla enim pariatur",
     *                     redaction: "Excepteur magna",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 tableRuleParams: {
     *                     vaultID: "",
     *                     tableName: "in velit si",
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "eu labore in",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 columnGroupRuleParams: {
     *                     vaultID: "commodo amet",
     *                     columnGroups: ["magna ut Excepteur", "Excepteur aliquip", "com"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "proident incididunt ut ",
     *                     redaction: "exercitation ut laborum et",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 }
     *             }, {
     *                 name: "aliqua",
     *                 ID: "ipsum deserunt consequat",
     *                 ruleExpression: "occaecat nostrud",
     *                 columnRuleParams: {
     *                     vaultID: "velit aute nostrud aliqua ut",
     *                     columns: ["consequat commodo ipsum deserunt", "mollit esse", "anim nostrud dolore elit qui"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "aliqua fugiat veniam",
     *                     redaction: "Duis reprehenderit id velit Lorem",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 tableRuleParams: {
     *                     vaultID: "ipsum Duis",
     *                     tableName: "mollit non dolore",
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "v",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 columnGroupRuleParams: {
     *                     vaultID: "ut exercitation",
     *                     columnGroups: ["incididunt Duis est", "id ipsum", "enim Excepteur"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "ipsum",
     *                     redaction: "irure ex dolore in deserunt",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 }
     *             }],
     *         activated: false
     *     })
     */
    public policyAuthoringServiceCreatePolicy(
        request: Skyflow.V1CreatePolicyRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1CreatePolicyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__policyAuthoringServiceCreatePolicy(request, requestOptions));
    }

    private async __policyAuthoringServiceCreatePolicy(
        request: Skyflow.V1CreatePolicyRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1CreatePolicyResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                "v1/policies",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1CreatePolicyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling POST /v1/policies.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Assigns a policy to one or more <a href='#Roles'>roles</a>.
     *
     * @param {Skyflow.V1AssignPolicyRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceAssignPolicy({
     *         ID: "id ut elit irure",
     *         roleIDs: ["aute", "anim incididunt ut adipisicing", "culpa irure"],
     *         members: [{
     *                 ID: "ullamco Duis est in",
     *                 type: "NONE",
     *                 name: "incididunt",
     *                 email: "vol",
     *                 status: "NONE"
     *             }, {
     *                 ID: "commodo aliquip",
     *                 type: "NONE",
     *                 name: "eu nostrud",
     *                 email: "cupidatat Excepteur nisi do in",
     *                 status: "NONE"
     *             }, {
     *                 ID: "dolor proident adipisicing ullamco",
     *                 type: "NONE",
     *                 name: "ullamco cupidatat Lore",
     *                 email: "ea anim des",
     *                 status: "NONE"
     *             }],
     *         exceptions: [{
     *                 ID: "ex dolore fugiat",
     *                 type: "NONE",
     *                 name: "vol",
     *                 email: "id consequat",
     *                 status: "NONE"
     *             }, {
     *                 ID: "do id eu",
     *                 type: "NONE",
     *                 name: "do ",
     *                 email: "tempo",
     *                 status: "NONE"
     *             }, {
     *                 ID: "Ut deserunt officia",
     *                 type: "NONE",
     *                 name: "eiusmod sunt ullamco dolore",
     *                 email: "Duis esse Excepteur non dolore",
     *                 status: "NONE"
     *             }]
     *     })
     */
    public policyAuthoringServiceAssignPolicy(
        request: Skyflow.V1AssignPolicyRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1AssignPolicyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__policyAuthoringServiceAssignPolicy(request, requestOptions));
    }

    private async __policyAuthoringServiceAssignPolicy(
        request: Skyflow.V1AssignPolicyRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1AssignPolicyResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                "v1/policies/assign",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1AssignPolicyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling POST /v1/policies/assign.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a rule in a policy.
     *
     * @param {Skyflow.V1CreateRuleRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceCreateRule({
     *         policyID: "enim",
     *         ruleParams: {
     *             name: "aute aliquip et",
     *             ID: "proident ut sed",
     *             ruleExpression: "nostrud velit reprehenderit",
     *             columnRuleParams: {
     *                 vaultID: "amet ut aliqua sed occaecat",
     *                 columns: ["laboris quis occaecat", "laborum", "consequat Ut voluptate nisi esse"],
     *                 action: "NONE_ACTION",
     *                 effect: "NONE_EFFECT",
     *                 rowFilter: "aliqua consequat aliquip id",
     *                 redaction: "Excepteur laboris aliqua",
     *                 actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *             },
     *             tableRuleParams: {
     *                 vaultID: "labore sed Ut mini",
     *                 tableName: "eu fugiat",
     *                 action: "NONE_ACTION",
     *                 effect: "NONE_EFFECT",
     *                 rowFilter: "dolore Duis deserunt officia",
     *                 actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *             },
     *             columnGroupRuleParams: {
     *                 vaultID: "ad ea",
     *                 columnGroups: ["esse velit qui", "proident sit consectetur dolore pariatur", "in Ut adipisicing quis sed"],
     *                 action: "NONE_ACTION",
     *                 effect: "NONE_EFFECT",
     *                 rowFilter: "nostrud sunt culpa sed",
     *                 redaction: "ullamco",
     *                 actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *             }
     *         }
     *     })
     */
    public policyAuthoringServiceCreateRule(
        request: Skyflow.V1CreateRuleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1CreateRuleResponse> {
        return core.HttpResponsePromise.fromPromise(this.__policyAuthoringServiceCreateRule(request, requestOptions));
    }

    private async __policyAuthoringServiceCreateRule(
        request: Skyflow.V1CreateRuleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1CreateRuleResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                "v1/policies/rules",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1CreateRuleResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling POST /v1/policies/rules.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the specified rule.
     *
     * @param {string} id - ID of the rule.
     * @param {Skyflow.PolicyAuthoringServiceGetRuleRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceGetRule("ID", {
     *         policyID: "policyID"
     *     })
     */
    public policyAuthoringServiceGetRule(
        id: string,
        request: Skyflow.PolicyAuthoringServiceGetRuleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1GetRuleResponse> {
        return core.HttpResponsePromise.fromPromise(this.__policyAuthoringServiceGetRule(id, request, requestOptions));
    }

    private async __policyAuthoringServiceGetRule(
        id: string,
        request: Skyflow.PolicyAuthoringServiceGetRuleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1GetRuleResponse>> {
        const { policyID: policyId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (policyId != null) {
            _queryParams["policyID"] = policyId;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/policies/rules/${encodeURIComponent(id)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1GetRuleResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling GET /v1/policies/rules/{ID}.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a rule from a policy.
     *
     * @param {string} id - ID of the rule.
     * @param {Skyflow.PolicyAuthoringServiceDeleteRuleRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceDeleteRule("ID", {
     *         policyID: "policyID"
     *     })
     */
    public policyAuthoringServiceDeleteRule(
        id: string,
        request: Skyflow.PolicyAuthoringServiceDeleteRuleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1DeleteRuleResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__policyAuthoringServiceDeleteRule(id, request, requestOptions),
        );
    }

    private async __policyAuthoringServiceDeleteRule(
        id: string,
        request: Skyflow.PolicyAuthoringServiceDeleteRuleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1DeleteRuleResponse>> {
        const { policyID: policyId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (policyId != null) {
            _queryParams["policyID"] = policyId;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/policies/rules/${encodeURIComponent(id)}`,
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1DeleteRuleResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling DELETE /v1/policies/rules/{ID}.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update a rule.
     *
     * @param {string} id - ID of the rule.
     * @param {Skyflow.PolicyAuthoringServiceUpdateRuleBody} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceUpdateRule("ID", {
     *         policyID: "in consequat",
     *         ruleParams: {
     *             name: "",
     *             ID: "ea labore i",
     *             ruleExpression: "ullamco mollit est consectetur aliquip",
     *             columnRuleParams: {
     *                 vaultID: "laboris p",
     *                 columns: ["esse", "et Lorem", "do id"],
     *                 action: "NONE_ACTION",
     *                 effect: "NONE_EFFECT",
     *                 rowFilter: "Lorem",
     *                 redaction: "ullamco Excepteur incididunt",
     *                 actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *             },
     *             tableRuleParams: {
     *                 vaultID: "veli",
     *                 tableName: "tempor commodo",
     *                 action: "NONE_ACTION",
     *                 effect: "NONE_EFFECT",
     *                 rowFilter: "Ut in proident amet dolor",
     *                 actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *             },
     *             columnGroupRuleParams: {
     *                 vaultID: "sint",
     *                 columnGroups: ["do", "nostrud occaecat", "irure in aute fugiat Lorem"],
     *                 action: "NONE_ACTION",
     *                 effect: "NONE_EFFECT",
     *                 rowFilter: "irure voluptate",
     *                 redaction: "Lorem incididunt",
     *                 actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *             }
     *         }
     *     })
     */
    public policyAuthoringServiceUpdateRule(
        id: string,
        request: Skyflow.PolicyAuthoringServiceUpdateRuleBody = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1UpdateRuleResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__policyAuthoringServiceUpdateRule(id, request, requestOptions),
        );
    }

    private async __policyAuthoringServiceUpdateRule(
        id: string,
        request: Skyflow.PolicyAuthoringServiceUpdateRuleBody = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1UpdateRuleResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/policies/rules/${encodeURIComponent(id)}`,
            ),
            method: "PATCH",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1UpdateRuleResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling PATCH /v1/policies/rules/{ID}.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Unassigns a policy from one or more <a href='#Roles'>roles</a>.
     *
     * @param {Skyflow.V1UnassignPolicyRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceUnassignPolicy({
     *         ID: "labore est ut occaecat",
     *         roleIDs: ["aliquip quis", "sit", "aliquip non"],
     *         members: [{
     *                 ID: "sint sed Lorem",
     *                 type: "NONE",
     *                 name: "in qui ex",
     *                 email: "id tempor labore proident ea",
     *                 status: "NONE"
     *             }, {
     *                 ID: "laboris nostrud laborum",
     *                 type: "NONE",
     *                 name: "laborum dolor officia deser",
     *                 email: "aliquip aliqua magna",
     *                 status: "NONE"
     *             }, {
     *                 ID: "reprehenderit do ",
     *                 type: "NONE",
     *                 name: "aliqua dolor ea al",
     *                 email: "adipisicing",
     *                 status: "NONE"
     *             }]
     *     })
     */
    public policyAuthoringServiceUnassignPolicy(
        request: Skyflow.V1UnassignPolicyRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1UnassignPolicyResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__policyAuthoringServiceUnassignPolicy(request, requestOptions),
        );
    }

    private async __policyAuthoringServiceUnassignPolicy(
        request: Skyflow.V1UnassignPolicyRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1UnassignPolicyResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                "v1/policies/unassign",
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1UnassignPolicyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling POST /v1/policies/unassign.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the specified policy.
     *
     * @param {string} id - ID of the policy.
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceGetPolicy("ID")
     */
    public policyAuthoringServiceGetPolicy(
        id: string,
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1GetPolicyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__policyAuthoringServiceGetPolicy(id, requestOptions));
    }

    private async __policyAuthoringServiceGetPolicy(
        id: string,
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1GetPolicyResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/policies/${encodeURIComponent(id)}`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1GetPolicyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling GET /v1/policies/{ID}.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes the specified policy.
     *
     * @param {string} id - ID of the policy.
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceDeletePolicy("ID")
     */
    public policyAuthoringServiceDeletePolicy(
        id: string,
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1DeletePolicyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__policyAuthoringServiceDeletePolicy(id, requestOptions));
    }

    private async __policyAuthoringServiceDeletePolicy(
        id: string,
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1DeletePolicyResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/policies/${encodeURIComponent(id)}`,
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1DeletePolicyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling DELETE /v1/policies/{ID}.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates the specified policy.
     *
     * @param {string} id - ID of the policy.
     * @param {Skyflow.PolicyAuthoringServiceUpdatePolicyBody} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceUpdatePolicy("ID", {
     *         policy: {
     *             ID: "magna",
     *             name: "GA5aUSD3ixr",
     *             displayName: "consequat in adipisici",
     *             description: "dolore in",
     *             namespace: "sunt veniam magna ullamco incididunt",
     *             status: "NONE",
     *             BasicAudit: {
     *                 CreatedBy: "non sit qui labore",
     *                 LastModifiedBy: "in sed aliqua adipis",
     *                 CreatedOn: "ut consequat sint mollit",
     *                 LastModifiedOn: "eiusmod"
     *             },
     *             resource: {
     *                 ID: "veniam",
     *                 type: "NONE",
     *                 name: "nulla",
     *                 namespace: "enim magna",
     *                 description: "labore irure ut nisi laboris",
     *                 status: "NONE",
     *                 displayName: "esse eu"
     *             },
     *             members: ["aliqua veniam", "dolore", "ea labore incididunt Excepteur"],
     *             rules: [{
     *                     ID: "aute sunt ad min",
     *                     name: "gaznxQfIJs",
     *                     effect: "NONE_EFFECT",
     *                     actions: ["non officia magna labore occaecat", "incididunt velit dolore", "magna eiusmod tempor amet"],
     *                     resources: ["in", "consequat in co", "dese"],
     *                     resourceType: "ACCOUNT",
     *                     dlpFormat: "NONE_FORMAT",
     *                     condition: "enim sit ut a",
     *                     rowFilter: "deserunt ex aute",
     *                     ruleExpression: "qui",
     *                     redaction: "dolore nisi"
     *                 }, {
     *                     ID: "Excepteur Duis enim laborum",
     *                     name: "EguBWUd",
     *                     effect: "NONE_EFFECT",
     *                     actions: ["aliqua Excepteur", "cillum", "ullamco nisi"],
     *                     resources: ["in ipsum", "c", "culpa anim amet eiusmod ut"],
     *                     resourceType: "ACCOUNT",
     *                     dlpFormat: "NONE_FORMAT",
     *                     condition: "",
     *                     rowFilter: "quis occaecat sit",
     *                     ruleExpression: "cillum consectetur voluptate anim in",
     *                     redaction: "dolore"
     *                 }, {
     *                     ID: "sint et sit eu cupidatat",
     *                     name: "eK4rIu",
     *                     effect: "NONE_EFFECT",
     *                     actions: ["nisi", "eli", "nulla Lorem in labore"],
     *                     resources: ["dolore ex minim", "aliquip anim", "dolore Ut Lorem consectetur enim"],
     *                     resourceType: "ACCOUNT",
     *                     dlpFormat: "NONE_FORMAT",
     *                     condition: "exercitation",
     *                     rowFilter: "deserunt et",
     *                     ruleExpression: "ipsum sed ea voluptate aute",
     *                     redaction: "dolor sit"
     *                 }]
     *         },
     *         ruleParams: [{
     *                 name: "et anim",
     *                 ID: "dolore",
     *                 ruleExpression: "amet sit consectetur ipsum laborum",
     *                 columnRuleParams: {
     *                     vaultID: "qui occaecat ad n",
     *                     columns: ["in in qui", "cupidatat quis pariat", "sit"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "eiusmod nulla dolore id ea",
     *                     redaction: "enim laboris officia",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 tableRuleParams: {
     *                     vaultID: "amet est dolore Excepteur",
     *                     tableName: "nisi dolore Ut",
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "nulla",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 columnGroupRuleParams: {
     *                     vaultID: "anim",
     *                     columnGroups: ["in et tempor amet", "consequat esse in", "dolor consequat"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "dolor Lorem esse tempor adipisicing",
     *                     redaction: "labore",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 }
     *             }, {
     *                 name: "ex sed veniam in",
     *                 ID: "ad voluptate laboris veniam id",
     *                 ruleExpression: "magna qui labore incididunt Ut",
     *                 columnRuleParams: {
     *                     vaultID: "minim anim mollit fugiat",
     *                     columns: ["Duis dolor officia", "Excepteur sed non ipsum", "Ut"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "nulla sint Excepteur",
     *                     redaction: "aute",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 tableRuleParams: {
     *                     vaultID: "et consequat Duis sit amet",
     *                     tableName: "eu nisi in in Ut",
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "consequat tempor commodo dolor labore",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 columnGroupRuleParams: {
     *                     vaultID: "Excepteur ea culpa",
     *                     columnGroups: ["aliquip sunt", "incididunt", "Lorem cupidatat"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "mollit exercitation amet nisi pariat",
     *                     redaction: "nostrud",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 }
     *             }, {
     *                 name: "commodo id enim",
     *                 ID: "qui nisi",
     *                 ruleExpression: "sint do tempor voluptate Duis",
     *                 columnRuleParams: {
     *                     vaultID: "est incididunt enim id",
     *                     columns: ["ut pariatur ", "ut incididunt", "Lorem nisi"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "Duis moll",
     *                     redaction: "eiu",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 tableRuleParams: {
     *                     vaultID: "magna consequat",
     *                     tableName: "culpa sint aliquip nisi magna",
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "ipsum reprehenderit occaecat magna c",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 },
     *                 columnGroupRuleParams: {
     *                     vaultID: "commodo",
     *                     columnGroups: ["aute eiusmod", "nostrud ut aute commodo magna", "anim ex laboru"],
     *                     action: "NONE_ACTION",
     *                     effect: "NONE_EFFECT",
     *                     rowFilter: "Lorem com",
     *                     redaction: "nostrud dolore adipis",
     *                     actions: ["NONE_ACTION", "NONE_ACTION", "NONE_ACTION"]
     *                 }
     *             }]
     *     })
     */
    public policyAuthoringServiceUpdatePolicy(
        id: string,
        request: Skyflow.PolicyAuthoringServiceUpdatePolicyBody = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1UpdatePolicyResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__policyAuthoringServiceUpdatePolicy(id, request, requestOptions),
        );
    }

    private async __policyAuthoringServiceUpdatePolicy(
        id: string,
        request: Skyflow.PolicyAuthoringServiceUpdatePolicyBody = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1UpdatePolicyResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/policies/${encodeURIComponent(id)}`,
            ),
            method: "PATCH",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1UpdatePolicyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling PATCH /v1/policies/{ID}.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates a policy's status.
     *
     * @param {string} id - ID of the entity to update.
     * @param {Skyflow.V1PolicyAuthoringServiceUpdateStatusBody} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceUpdateStatus("ID", {
     *         status: "NONE"
     *     })
     */
    public policyAuthoringServiceUpdateStatus(
        id: string,
        request: Skyflow.V1PolicyAuthoringServiceUpdateStatusBody = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1UpdateStatusResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__policyAuthoringServiceUpdateStatus(id, request, requestOptions),
        );
    }

    private async __policyAuthoringServiceUpdateStatus(
        id: string,
        request: Skyflow.V1PolicyAuthoringServiceUpdateStatusBody = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1UpdateStatusResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/policies/${encodeURIComponent(id)}/status`,
            ),
            method: "PATCH",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1UpdateStatusResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling PATCH /v1/policies/{ID}/status.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Lists policies assigned to a role.
     *
     * @param {string} roleId - ID of the role.
     * @param {Skyflow.PolicyAuthoringServiceListPoliciesByRoleRequest} request
     * @param {Policies.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Skyflow.NotFoundError}
     *
     * @example
     *     await client.policies.policyAuthoringServiceListPoliciesByRole("roleID", {
     *         "filterOps.name": "filterOps.name",
     *         "sortOps.sortBy": "sortOps.sortBy",
     *         "sortOps.orderBy": "ASCENDING",
     *         offset: "offset",
     *         limit: "limit"
     *     })
     */
    public policyAuthoringServiceListPoliciesByRole(
        roleId: string,
        request: Skyflow.PolicyAuthoringServiceListPoliciesByRoleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): core.HttpResponsePromise<Skyflow.V1ListPoliciesByRoleResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__policyAuthoringServiceListPoliciesByRole(roleId, request, requestOptions),
        );
    }

    private async __policyAuthoringServiceListPoliciesByRole(
        roleId: string,
        request: Skyflow.PolicyAuthoringServiceListPoliciesByRoleRequest = {},
        requestOptions?: Policies.RequestOptions,
    ): Promise<core.WithRawResponse<Skyflow.V1ListPoliciesByRoleResponse>> {
        const {
            "filterOps.name": filterOpsName,
            "sortOps.sortBy": sortOpsSortBy,
            "sortOps.orderBy": sortOpsOrderBy,
            offset,
            limit,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (filterOpsName != null) {
            _queryParams["filterOps.name"] = filterOpsName;
        }

        if (sortOpsSortBy != null) {
            _queryParams["sortOps.sortBy"] = sortOpsSortBy;
        }

        if (sortOpsOrderBy != null) {
            _queryParams["sortOps.orderBy"] = sortOpsOrderBy;
        }

        if (offset != null) {
            _queryParams["offset"] = offset;
        }

        if (limit != null) {
            _queryParams["limit"] = limit;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SkyflowEnvironment.Production,
                `v1/roles/${encodeURIComponent(roleId)}/policies`,
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Skyflow-Account-ID":
                    (await core.Supplier.get(this._options.skyflowAccountId)) != null
                        ? await core.Supplier.get(this._options.skyflowAccountId)
                        : undefined,
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "skyflow",
                "X-Fern-SDK-Version": "1.0.21",
                "User-Agent": "skyflow/1.0.21",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Skyflow.V1ListPoliciesByRoleResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Skyflow.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.SkyflowError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SkyflowError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SkyflowTimeoutError("Timeout exceeded when calling GET /v1/roles/{roleID}/policies.");
            case "unknown":
                throw new errors.SkyflowError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
